<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ditherpunk State Space Model - Auto Fit</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            /* Theme: Black Background, Green/Orange/White Accents */
            --bg-color: #050505;
            --text-color: #00ff41; /* Terminal Green */
            --color-truth: #666666; /* Dim White/Grey */
            --color-obs: #ffffff;   /* Bright White */
            --color-filter: #00ff41; /* Green */
            --color-smooth: #ff9900; /* Orange */
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'VT323', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        /* The Dithered Background Layer */
        #dither-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1; /* Reduced opacity for dark mode */
            pointer-events: none;
        }

        /* UI Container */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.85); /* Dark semi-transparent */
            border: 2px solid var(--text-color);
            padding: 15px;
            box-shadow: 6px 6px 0px rgba(0, 255, 65, 0.2);
            max-width: 280px;
        }

        h1 {
            font-size: 28px;
            margin: 0 0 15px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 3px dashed var(--text-color);
            padding-bottom: 5px;
            line-height: 1;
            color: #ffffff;
            text-shadow: 0 0 5px rgba(0,255,65,0.5);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 20px;
        }

        .swatch {
            width: 18px;
            height: 18px;
            margin-right: 12px;
            border: 2px solid transparent;
        }

        #status-indicator {
            margin-top: 20px;
            font-size: 22px;
            font-weight: bold;
            padding: 8px;
            background: #000000;
            color: var(--text-color);
            text-align: center;
            border: 2px solid var(--text-color);
        }

        /* Scanline effect overlay */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 20;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <div id="dither-bg"></div>
    <div class="scanlines"></div>

    <div id="ui-layer">
        <h1>State Space<br>Model</h1>
        
        <div class="legend-item">
            <div class="swatch" style="border: none; border-bottom: 3px dashed var(--color-truth); height: 10px; transform: translateY(-5px);"></div>
            <span>Ground Truth</span>
        </div>
        <div class="legend-item">
            <div class="swatch" style="background: var(--color-obs); border: 1px solid #333;"></div>
            <span>Observation</span>
        </div>
        <div class="legend-item">
            <div class="swatch" style="background: var(--color-filter); border: 1px solid #333;"></div>
            <span>Filter (KF)</span>
        </div>
        <div class="legend-item">
            <div class="swatch" style="background: var(--color-smooth); border: 1px solid #333;"></div>
            <span>Smoother (RTS)</span>
        </div>

        <div id="status-indicator">INITIALIZING</div>
    </div>

    <canvas id="mainCanvas"></canvas>

<script>
/**
 * DITHERPUNK STATE SPACE MODEL
 * Robust Auto-Scaling Version
 */

// --- 1. PROCEDURAL NOISE (Atkinson Dithering) ---

function generateAtkinsonNoise() {
    const w = 256; 
    const h = 256;
    const c = document.createElement('canvas');
    c.width = w;
    c.height = h;
    const ctx = c.getContext('2d');
    
    const imgData = ctx.createImageData(w, h);
    const data = imgData.data;
    
    // Noise base
    for (let i = 0; i < data.length; i += 4) {
        const gray = Math.random() * 255;
        data[i] = gray;
        data[i+1] = gray;
        data[i+2] = gray;
        data[i+3] = 255;
    }

    // Atkinson Dithering
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const i = (y * w + x) * 4;
            const oldPixel = data[i];
            const newPixel = oldPixel < 128 ? 0 : 255;
            const err = (oldPixel - newPixel) / 8;

            data[i] = newPixel;
            data[i+1] = newPixel;
            data[i+2] = newPixel;

            const neighbors = [
                {dx: 1, dy: 0}, {dx: 2, dy: 0},
                {dx: -1, dy: 1}, {dx: 0, dy: 1}, {dx: 1, dy: 1},
                {dx: 0, dy: 2}
            ];

            neighbors.forEach(n => {
                const nx = x + n.dx;
                const ny = y + n.dy;
                if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                    const ni = (ny * w + nx) * 4;
                    data[ni] += err;
                    data[ni+1] += err;
                    data[ni+2] += err;
                }
            });
        }
    }
    ctx.putImageData(imgData, 0, 0);
    return c.toDataURL();
}

document.getElementById('dither-bg').style.backgroundImage = `url(${generateAtkinsonNoise()})`;


// --- 2. MATH SIMULATION ---

const SIM_STEPS = 120;
let DATA_MIN = 0; // Will be calculated dynamically
let DATA_MAX = 100;

const SIM_DATA = {
    truth: [],
    obs: [],
    filterEst: [],
    filterCov: [],
    smoothEst: []
};

function runSimulation() {
    // Parameters
    const A = 1; 
    const H = 1;
    const Q = 0.5;
    const R = 40.0; // High noise
    
    SIM_DATA.truth = [];
    SIM_DATA.obs = [];
    SIM_DATA.filterEst = [];
    SIM_DATA.filterCov = [];
    SIM_DATA.smoothEst = [];
    
    const P_preds = [];
    const x_preds = [];

    let trueState = 50;

    // 1. Generate Data
    for (let i = 0; i < SIM_STEPS; i++) {
        const sineComponent = Math.sin(i * 0.12) * 40; // Oscillation
        trueState = sineComponent + 50; 
        
        const noise = (Math.random() - 0.5) * 2 * Math.sqrt(R * 3);
        const measurement = trueState + noise;

        SIM_DATA.truth.push(trueState);
        SIM_DATA.obs.push(measurement);
    }

    // 2. Kalman Filter
    let x_hat = 50; 
    let P = 50;
    
    for (let i = 0; i < SIM_STEPS; i++) {
        const z = SIM_DATA.obs[i];

        // Predict
        let x_pred = A * x_hat;
        let P_pred = A * P * A + Q;
        
        P_preds.push(P_pred);
        x_preds.push(x_pred);

        // Update
        const K = P_pred * H / (H * P_pred * H + R);
        x_hat = x_pred + K * (z - H * x_pred);
        P = (1 - K * H) * P_pred;

        SIM_DATA.filterEst.push(x_hat);
        SIM_DATA.filterCov.push(P);
    }

    // 3. RTS Smoother
    const N = SIM_STEPS;
    let x_smooth = new Array(N);
    x_smooth[N-1] = SIM_DATA.filterEst[N-1];

    for (let k = N - 2; k >= 0; k--) {
        const P_curr = SIM_DATA.filterCov[k];
        const P_next_pred = P_preds[k+1];
        const C = P_curr * A * (1.0 / P_next_pred);
        x_smooth[k] = SIM_DATA.filterEst[k] + C * (x_smooth[k+1] - x_preds[k+1]);
    }
    SIM_DATA.smoothEst = x_smooth;

    // --- AUTO SCALING CALCULATION ---
    // Find min and max of all relevant data to ensure it fits on screen
    const allValues = [
        ...SIM_DATA.obs, 
        ...SIM_DATA.truth,
        ...SIM_DATA.filterEst
    ];
    
    const rawMin = Math.min(...allValues);
    const rawMax = Math.max(...allValues);
    const range = rawMax - rawMin;

    // Add padding (20%)
    DATA_MIN = rawMin - (range * 0.15);
    DATA_MAX = rawMax + (range * 0.15);
}


// --- 3. RENDERING ENGINE ---

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status-indicator');

let width, height;
let animIndex = 0;
let animPhase = 'FILTER'; // 'FILTER' | 'SMOOTH' | 'WAIT'
let animTimer = 0;

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    ctx.imageSmoothingEnabled = false;
}
window.addEventListener('resize', resize);
resize();
runSimulation();

// --- Coordinate Mapping (DYNAMIC) ---
function mapX(i) {
    const margin = width * 0.05; // 5% side margins
    const w = width - (margin * 2);
    return margin + (i / (SIM_STEPS - 1)) * w;
}

function mapY(val) {
    const margin = height * 0.10; // 10% top/bottom vertical margin
    const plotHeight = height - (margin * 2);
    
    // Normalize based on Dynamic Min/Max
    const norm = (val - DATA_MIN) / (DATA_MAX - DATA_MIN);
    
    // Invert Y (Canvas 0 is top)
    return (height - margin) - (norm * plotHeight);
}

function drawGrid() {
    ctx.strokeStyle = '#333333'; // Dark grey grid
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 5]);
    
    // Draw 5 horizontal lines distributed across the Dynamic Range
    const lines = 5;
    ctx.textAlign = 'right';
    ctx.fillStyle = '#00aa00'; // Dim green text
    ctx.font = '16px VT323';

    for(let i=0; i <= lines; i++) {
        const fraction = i / lines;
        const dataVal = DATA_MIN + fraction * (DATA_MAX - DATA_MIN);
        const y = mapY(dataVal);
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();

        // Optional: Draw value label on the right edge
        // ctx.fillText(Math.round(dataVal), width - 10, y - 5);
    }

    // Verticals
    for(let i=0; i<=20; i++) {
        const x = (width / 20) * i;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
    }
    ctx.setLineDash([]);
}

function drawArrow(x, y, angle, color) {
    const size = 12;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-size, -size/1.8);
    ctx.lineTo(-size, size/1.8);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function render() {
    ctx.clearRect(0, 0, width, height);
    drawGrid();

    // 1. Observations
    const maxObsIndex = (animPhase === 'FILTER') ? animIndex : SIM_STEPS;
    ctx.fillStyle = '#ffffff'; // White observations
    for (let i = 0; i < maxObsIndex; i++) {
        const cx = mapX(i);
        const cy = mapY(SIM_DATA.obs[i]);
        ctx.fillRect(cx - 3, cy - 3, 6, 6);
    }

    // 2. Truth
    ctx.strokeStyle = '#666666'; // Dim grey/white
    ctx.lineWidth = 2.5;
    ctx.setLineDash([6, 6]);
    ctx.beginPath();
    for (let i = 0; i < maxObsIndex; i++) {
        const x = mapX(i);
        const y = mapY(SIM_DATA.truth[i]);
        if (i===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // 3. Filter (Green)
    const maxFilterIndex = (animPhase === 'FILTER') ? animIndex : SIM_STEPS;
    
    if (maxFilterIndex > 0) {
        ctx.strokeStyle = '#00ff41'; // Matrix Green
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        for (let i = 0; i < maxFilterIndex; i++) {
            const x = mapX(i);
            const y = mapY(SIM_DATA.filterEst[i]);
            if (i===0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Arrow
        if (animPhase === 'FILTER' && animIndex > 1) {
            const cx = mapX(animIndex-1);
            const cy = mapY(SIM_DATA.filterEst[animIndex-1]);
            const px = mapX(animIndex-2);
            const py = mapY(SIM_DATA.filterEst[animIndex-2]);
            const angle = Math.atan2(cy - py, cx - px);
            drawArrow(cx, cy, angle, '#00ff41');
        }
    }

    // 4. Smoother (Orange)
    if (animPhase === 'SMOOTH' || animPhase === 'WAIT') {
        const startIndex = SIM_STEPS - 1;
        const endIndex = (animPhase === 'SMOOTH') ? animIndex : 0;

        ctx.strokeStyle = '#ff9900'; // High-vis Orange
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        for (let i = startIndex; i >= endIndex; i--) {
            const x = mapX(i);
            const y = mapY(SIM_DATA.smoothEst[i]);
            if (i === startIndex) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Arrow
        if (animPhase === 'SMOOTH' && animIndex < SIM_STEPS - 2) {
            const cx = mapX(animIndex);
            const cy = mapY(SIM_DATA.smoothEst[animIndex]);
            const px = mapX(animIndex+1);
            const py = mapY(SIM_DATA.smoothEst[animIndex+1]);
            const angle = Math.atan2(cy - py, cx - px);
            drawArrow(cx, cy, angle, '#ff9900');
        }
    }
}

function loop() {
    render();

    if (animPhase === 'FILTER') {
        statusEl.textContent = "PHASE 1: FILTERING (t ->)";
        statusEl.style.color = '#00ff41';
        statusEl.style.background = '#000000';
        statusEl.style.borderColor = '#00ff41';

        animIndex++;
        if (animIndex >= SIM_STEPS) {
            animPhase = 'SMOOTH';
            animIndex = SIM_STEPS - 1;
        }
    } 
    else if (animPhase === 'SMOOTH') {
        statusEl.textContent = "PHASE 2: SMOOTHING (<- t)";
        statusEl.style.color = '#ff9900';
        statusEl.style.background = '#000000';
        statusEl.style.borderColor = '#ff9900';

        animIndex--;
        if (animIndex < 0) {
            animPhase = 'WAIT';
            animIndex = 0;
            animTimer = 0;
        }
    } 
    else if (animPhase === 'WAIT') {
        statusEl.textContent = "SIMULATION COMPLETE";
        statusEl.style.color = '#000000';
        statusEl.style.background = '#ffffff';
        statusEl.style.borderColor = '#ffffff';
        
        animTimer++;
        if (animTimer > 150) { 
            runSimulation();
            animPhase = 'FILTER';
            animIndex = 0;
        }
    }

    requestAnimationFrame(loop);
}

// Start
loop();

</script>
</body>
</html>