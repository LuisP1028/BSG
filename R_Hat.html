<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GELMAN_RUBIN // PHOSPHOR_MODE</title>
    <style>
        :root {
            /* Palette: Phosphor Green */
            --bg: #000000;
            --fg: #00FF41;      /* Classic Terminal Green */
            --dim: #004411;     /* Dim green for grids/borders */
            --shadow-col: #002200;
            
            --border-thick: 2px solid var(--fg);
            --border-thin: 1px solid var(--fg);
            --font-main: 'Courier Prime', 'VT323', 'Courier New', monospace;
        }

        * {
            box-sizing: border-box;
            -webkit-font-smoothing: none;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-main);
            margin: 0;
            /* Flex centering for the dashboard */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }

        /* Dithered background texture */
        #dither-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
            pointer-events: none;
        }

        .container {
            width: 100%;
            max-width: 1200px; /* Slightly wider for better trace viewing */
            border: var(--border-thick);
            background: var(--bg);
            /* Hard pixelated shadow, now dark green */
            box-shadow: 8px 8px 0px var(--shadow-col);
            display: flex;
            flex-direction: column;
        }

        header {
            border-bottom: var(--border-thick);
            padding: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            background: var(--bg);
            gap: 10px;
        }

        h1 {
            margin: 0;
            font-size: 1.4rem;
            font-weight: bold;
            text-shadow: 0 0 5px var(--fg); /* Glow effect */
        }

        .subtitle {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        main {
            display: grid;
            /* Responsive Grid: Trace Plot gets more space */
            grid-template-columns: 2.5fr 1fr; 
            gap: 2px;
            background-color: var(--fg); /* Creates the gap borders */
            border-bottom: var(--border-thick);
            flex-grow: 1;
        }

        .panel {
            background-color: var(--bg);
            padding: 10px;
            position: relative;
            min-height: 350px;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent canvas blowouts */
        }

        .panel-header {
            font-weight: bold;
            border-bottom: 1px dashed var(--fg);
            margin-bottom: 10px;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-transform: uppercase;
            font-size: 0.9rem;
        }

        canvas {
            width: 100%;
            height: 100%;
            flex-grow: 1;
            image-rendering: pixelated; /* Crisp pixels */
            border: 1px solid var(--dim);
            background: #000500;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 15px;
            font-size: 0.8rem;
            border-top: 1px solid var(--dim);
            padding-top: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
        }

        .stat-val {
            font-weight: bold;
            font-family: monospace;
        }

        footer {
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg);
            font-size: 0.8rem;
        }

        button {
            background: var(--bg);
            color: var(--fg);
            border: var(--border-thick);
            padding: 10px 20px;
            font-family: var(--font-main);
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 4px 4px 0px var(--shadow-col);
            transition: all 0.1s;
        }

        button:hover {
            background: var(--fg);
            color: var(--bg);
            box-shadow: 4px 4px 0px var(--fg);
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px var(--shadow-col);
        }

        .legend {
            display: flex;
            gap: 15px;
            font-size: 0.75rem;
        }
        
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .line-solid { width: 15px; height: 2px; background: var(--fg); }
        .line-dash { width: 15px; height: 2px; border-bottom: 2px dashed var(--fg); }
        .line-dot { width: 15px; height: 2px; border-bottom: 2px dotted var(--fg); }

        .r-indicator {
            padding: 2px 6px;
            border: 1px solid var(--fg);
            font-weight: bold;
        }
        .r-safe { background: var(--fg); color: var(--bg); }
        .r-danger { background: var(--bg); color: var(--fg); }

        /* Responsive Adjustments */
        @media (max-width: 800px) {
            main { grid-template-columns: 1fr; }
            .panel { min-height: 250px; }
            header { flex-direction: column; align-items: flex-start; }
            .legend { display: none; } /* Hide legend on small screens to save space */
        }
    </style>
</head>
<body>

<canvas id="dither-bg"></canvas>

<div class="container">
    <header>
        <div>
            <h1>MCMC_DIAGNOSTIC_V2.0</h1>
            <div class="subtitle">SYSTEM: TERMINAL // PHOSPHOR_GREEN</div>
        </div>
        <div style="text-align: right; display: flex; gap: 15px;">
            <div>STATUS: <span id="status-text">RUNNING</span></div>
            <div>FPS: <span id="fps">00</span></div>
        </div>
    </header>

    <main>
        <!-- PANEL A: TRACE PLOT -->
        <div class="panel">
            <div class="panel-header">
                <span>TRACE_PLOT [MIXING]</span>
                <div class="legend">
                    <div class="legend-item"><div class="line-solid"></div>CH_A</div>
                    <div class="legend-item"><div class="line-dash"></div>CH_B</div>
                    <div class="legend-item"><div class="line-dot"></div>CH_C</div>
                </div>
            </div>
            <canvas id="traceCanvas"></canvas>
            <div style="font-size: 0.7rem; margin-top: 5px; color: var(--fg); opacity: 0.8;">
                > TRACKING 3 MARKOV CHAINS. TARGET: N(0,1).
            </div>
        </div>

        <!-- PANEL B: R-HAT METER -->
        <div class="panel">
            <div class="panel-header">
                <span>R_HAT_METER</span>
                <span id="r-value-display" class="r-indicator r-danger">R: ---</span>
            </div>
            <canvas id="rCanvas"></canvas>
            
            <div class="stats-grid">
                <div class="stat-row">
                    <span>BETWEEN_VAR (B):</span>
                    <span id="val-b" class="stat-val">0.00</span>
                </div>
                <div class="stat-row">
                    <span>WITHIN_VAR (W):</span>
                    <span id="val-w" class="stat-val">0.00</span>
                </div>
                <div class="stat-row">
                    <span>ITERATIONS (N):</span>
                    <span id="val-n" class="stat-val">0</span>
                </div>
            </div>
            <div style="margin-top: 15px; font-size: 0.7rem; border: 1px dotted var(--fg); padding: 5px; opacity: 0.9;">
                <strong>DIAGNOSTIC:</strong><br>
                HIGH R implies chains have not mixed.<br>
                TARGET: R < 1.05
            </div>
        </div>
    </main>

    <footer>
        <button onclick="simulation.reset()">// REBOOT_SIMULATION</button>
        <div style="text-align: right; opacity: 0.7;">
            DITHERPUNK ENGINE<br>
            Â© 202X
        </div>
    </footer>
</div>

<script>
/**
 * DITHERPUNK AESTHETIC ENGINE: PHOSPHOR EDITION
 * Generates a static noise background using Green-channel Atkinson dithering.
 */
function generateDitherTexture() {
    const cvs = document.getElementById('dither-bg');
    const ctx = cvs.getContext('2d');
    
    // Resize to window
    const w = window.innerWidth;
    const h = window.innerHeight;
    cvs.width = w;
    cvs.height = h;

    const imgData = ctx.createImageData(w, h);
    const data = imgData.data;

    // 1. Generate Noise
    for (let i = 0; i < data.length; i += 4) {
        // Base color is black, noise is green
        // Very low probability of a bright pixel to simulate dust/static
        const noise = Math.random();
        let val = 0;
        
        if(noise > 0.95) {
            val = Math.random() * 80; // faint green
        }
        
        data[i] = 0;     // R
        data[i+1] = val; // G
        data[i+2] = 0;   // B
        data[i+3] = 255; // Alpha
    }

    // 2. Apply Dithering (Atkinson) to smooth the noise into a texture
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const i = (y * w + x) * 4;
            const oldPixel = data[i+1]; // Work on Green channel
            const newPixel = oldPixel < 40 ? 0 : 60; // Quantize to Black or Dim Green
            const quantError = oldPixel - newPixel;

            data[i+1] = newPixel;

            if (x + 1 < w)           data[((y)*w + (x+1))*4 + 1]     += quantError >> 3;
            if (x + 2 < w)           data[((y)*w + (x+2))*4 + 1]     += quantError >> 3;
            if (y + 1 < h && x > 0)  data[((y+1)*w + (x-1))*4 + 1]   += quantError >> 3;
            if (y + 1 < h)           data[((y+1)*w + (x))*4 + 1]     += quantError >> 3;
            if (y + 1 < h && x+1 < w) data[((y+1)*w + (x+1))*4 + 1]  += quantError >> 3;
            if (y + 2 < h)           data[((y+2)*w + (x))*4 + 1]     += quantError >> 3;
        }
    }

    ctx.putImageData(imgData, 0, 0);
}

// Handle window resizing for background
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(generateDitherTexture, 200);
});
generateDitherTexture();


/**
 * SIMULATION LOGIC
 */
class Chain {
    constructor(startValue, style) {
        this.current = startValue;
        this.history = [startValue];
        this.style = style; // 0=solid, 1=dash, 2=dot
    }

    step() {
        // Metropolis Proposal: Random Walk N(current, 0.5)
        const proposal = this.current + (Math.random() - 0.5) * 2.0; 
        
        // Target: Standard Normal N(0,1)
        // Log Ratio = -0.5 * (prop^2 - curr^2)
        const logRatio = -0.5 * (proposal * proposal - this.current * this.current);
        
        if (Math.log(Math.random()) < logRatio) {
            this.current = proposal;
        }
        
        this.history.push(this.current);
    }
}

class Simulation {
    constructor() {
        this.traceCanvas = document.getElementById('traceCanvas');
        this.traceCtx = this.traceCanvas.getContext('2d');
        
        this.rCanvas = document.getElementById('rCanvas');
        this.rCtx = this.rCanvas.getContext('2d');

        // Colors
        this.colBg = "#000000";
        this.colFg = "#00FF41";
        this.colDim = "#004411";
        this.colSafe = "#002200";

        this.reset();
        this.resize();
        
        window.addEventListener('resize', () => this.resize());
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        // High DPI scaling and responsive layout sizing
        const scale = window.devicePixelRatio || 1;
        
        // Helper to size canvas to its parent container
        const fitCanvas = (canvas, ctx) => {
            const parent = canvas.parentElement;
            // Get computing style to subtract padding if necessary, 
            // but for this layout, offsetWidth/Height is usually sufficient minus borders
            const rect = parent.getBoundingClientRect();
            // We subtract header height roughly or just take the remaining space?
            // simpler: CSS sets canvas to 100% size, we just match internal resolution
            canvas.width = canvas.offsetWidth * scale;
            canvas.height = canvas.offsetHeight * scale;
            ctx.scale(scale, scale);
            return { w: canvas.offsetWidth, h: canvas.offsetHeight };
        };

        const dimsA = fitCanvas(this.traceCanvas, this.traceCtx);
        this.widthA = dimsA.w;
        this.heightA = dimsA.h;

        const dimsB = fitCanvas(this.rCanvas, this.rCtx);
        this.widthB = dimsB.w;
        this.heightB = dimsB.h;
        
        // Force immediate redraw so it doesn't look blank until next frame
        if(this.chains) {
            this.drawTrace();
            this.drawDiagnostics();
        }
    }

    reset() {
        // Dispersed start points
        this.chains = [
            new Chain(-12.0, 0),
            new Chain(2.0, 1),
            new Chain(12.0, 2) 
        ];
        this.rHistory = [];
        this.iteration = 0;
        document.getElementById('status-text').innerText = "RUNNING";
        document.getElementById('status-text').style.color = this.colFg;
    }

    update() {
        this.iteration++;
        this.chains.forEach(c => c.step());

        // Gelman-Rubin Calculation (Simplified)
        if (this.iteration > 5) {
            const N = this.iteration;
            const M = this.chains.length;

            // Means
            const chainMeans = this.chains.map(c => c.history.reduce((a, b) => a + b, 0) / N);
            const grandMean = chainMeans.reduce((a, b) => a + b, 0) / M;

            // Between-Chain Variance (B)
            let sumSqDiffMeans = 0;
            chainMeans.forEach(m => sumSqDiffMeans += (m - grandMean) ** 2);
            const B = (N / (M - 1)) * sumSqDiffMeans;

            // Within-Chain Variance (W)
            let sumVars = 0;
            this.chains.forEach((c, idx) => {
                const mean = chainMeans[idx];
                const sumSqErr = c.history.reduce((a, b) => a + (b - mean) ** 2, 0);
                sumVars += (sumSqErr / (N - 1));
            });
            const W = sumVars / M;

            // R-hat
            const varHat = ((N - 1) / N) * W + (1 / N) * B;
            let rHat = Math.sqrt(varHat / W);
            if (isNaN(rHat)) rHat = 3.0;

            this.rHistory.push(rHat);

            // Update DOM
            if (this.iteration % 5 === 0) {
                document.getElementById('val-b').innerText = B.toFixed(2);
                document.getElementById('val-w').innerText = W.toFixed(2);
                document.getElementById('val-n').innerText = N;
                
                const rDisplay = document.getElementById('r-value-display');
                rDisplay.innerText = "R: " + rHat.toFixed(3);
                
                if(rHat < 1.05) {
                    rDisplay.className = "r-indicator r-safe";
                    if(rHat < 1.01) document.getElementById('status-text').innerText = "CONVERGED";
                } else {
                    rDisplay.className = "r-indicator r-danger";
                    document.getElementById('status-text').innerText = "RUNNING";
                }
            }
        } else {
            this.rHistory.push(null);
        }
    }

    drawTrace() {
        const ctx = this.traceCtx;
        const w = this.widthA;
        const h = this.heightA;
        
        ctx.fillStyle = this.colBg;
        ctx.fillRect(0, 0, w, h);

        // Center line
        ctx.strokeStyle = this.colDim;
        ctx.setLineDash([2, 4]);
        ctx.beginPath();
        ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
        ctx.stroke();

        const viewSize = 600;
        const startIndex = Math.max(0, this.iteration - viewSize);
        const count = this.iteration - startIndex;
        const yScale = h / 35; // Scale factor
        const yOffset = h / 2;

        this.chains.forEach(chain => {
            ctx.strokeStyle = this.colFg;
            ctx.lineWidth = 1.5;
            
            // Manual Dash for crispness
            if (chain.style === 1) ctx.setLineDash([4, 4]); 
            else if (chain.style === 2) ctx.setLineDash([1, 4]); 
            else ctx.setLineDash([]); 

            ctx.beginPath();
            for (let i = 0; i < count; i++) {
                const idx = startIndex + i;
                const val = chain.history[idx];
                const x = (i / (viewSize - 1)) * w;
                const y = yOffset - (val * yScale);

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        });
    }

    drawDiagnostics() {
        const ctx = this.rCtx;
        const w = this.widthB;
        const h = this.heightB;

        ctx.fillStyle = this.colBg;
        ctx.fillRect(0, 0, w, h);

        const minR = 0.95;
        const maxR = 4.0;
        const rRange = maxR - minR;
        
        const mapY = (val) => {
            let v = Math.min(Math.max(val, minR), maxR);
            return h - ((v - minR) / rRange) * h;
        }

        // Draw Safe Zone Background
        const safeY = mapY(1.05);
        ctx.fillStyle = this.colSafe;
        ctx.fillRect(0, safeY, w, h - safeY);

        // Threshold Line
        ctx.strokeStyle = this.colFg;
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.moveTo(0, safeY);
        ctx.lineTo(w, safeY);
        ctx.stroke();

        ctx.fillStyle = this.colFg;
        ctx.font = "10px monospace";
        ctx.fillText("THRESHOLD 1.05", 2, safeY - 4);

        // Plot R-Hat
        const viewSize = 600;
        const startIndex = Math.max(0, this.rHistory.length - viewSize);
        const count = this.rHistory.length - startIndex;

        ctx.beginPath();
        ctx.strokeStyle = this.colFg;
        ctx.setLineDash([]);
        ctx.lineWidth = 2;

        let started = false;
        for (let i = 0; i < count; i++) {
            const val = this.rHistory[startIndex + i];
            if (val === null) continue;

            const x = (i / (viewSize - 1)) * w;
            const y = mapY(val);

            if (!started) {
                ctx.moveTo(x, y);
                started = true;
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
    }

    loop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;
        
        this.update();
        this.drawTrace();
        this.drawDiagnostics();

        if (this.iteration % 20 === 0) {
            document.getElementById('fps').innerText = Math.round(1000/dt);
        }

        this.lastTime = timestamp;
        requestAnimationFrame(this.loop);
    }
}

// Init
const simulation = new Simulation();
</script>
</body>
</html>